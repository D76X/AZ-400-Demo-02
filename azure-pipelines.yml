# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
- main

stages:
  - stage: CI
    displayName: CI Stage
    jobs:
      - job: Build  
        displayName: Build_the_imgages_and_push_them_to_the_ACR     
        pool:
          vmImage: ubuntu-latest

        variables:  
        # ----------------------------------------------------
        # Azure DevOps Pipelines devices
        # enable this to print debug info to the Azure DevOps Pipelines console
        # system.debug: true   
        # ----------------------------------------------------
          buildConfiguration: 'Release'
          # --------------------------------------------------
          # the following are for Docker          
          imageRepository: 'webapps'          
          buildTag : '$(Build.BuildId)'                    
        # ----------------------------------------------------
  
        steps:
        
        - task: Bash@3
          displayName: Print Relevant Variables Values
          inputs:
             targetType: 'inline'
             script: |
               echo "System.Debug=$(System.Debug)"
               echo "Build.Repository.LocalPath=$(Build.Repository.LocalPath)"
          #displayName: Print Variables of imported Variable Groups
          #name: PrintVariableGroupsVariables
          #inputs:
          #    targetType: 'inline'
          #    script: |
          #      echo "System.Debug=$(System.Debug)"
          #      echo "KeyStoreAlias=$(KeyStoreAlias)"
          #      echo "SonarCloudOrganization=$(SonarCloudOrganization)"
          #      echo "SonarCloudProjectKey=$(SonarCloudProjectKey)"
          #      echo "SonarCloudProjectName=$(SonarCloudProjectName)"

        # https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/use-dotnet-v2?view=azure-pipelines
        # We want to build WebApp1 from source code on this ubuntu-latest agent but it does not come with a .Net SDK
        # by default thus we use this task to install the required SDK on the agent
        # However, it may be that on ubuntu-latest agent the .Net SDK 6.x is already installed these days
        # an therefore the following task may not be necessary. It is left as comment as a remeinder of the
        # fact that on a Linux agent you must take care of verifying whether the build tools you need are
        # present as a default or not and in the latter you must installed them in steps of the pipeline.
        # --------------------------------------------------------------------------
        #- task: UseDotNet@2 
        #  displayName: Install .Net Core 6 SDK  
        #  inputs:
        #    packageType: 'sdk'
        #    version: '6.x'
        # --------------------------------------------------------------------------

        # In the following steps of the CI Stage of this Pipeline WebApp1 and WebApp2 
        # are going to be containerized. However, the approach to containerization
        # used for WebApp1 and WebApp2 differs. WebApp1 is firstly build, then published
        # as a DLL and these binary assets are then stored to a subfolder WebApp1 of the
        # Pipeline Staging Directory PSD.
        # Later a Docker@2 tasks takes the contents of PSD/WebApp1 and copies it into a base
        # image that has what is required to run it when a container is created from it.
        # For WbeApp2 instead the source code itself is copied directly is consumed by
        # a Docker@2 task in the Pipeline and a multistage Dockerfile is used to build
        # the source code to produce the binary output and then copy the binary output
        # from the intermediate layer into a final image.
        # For WebApp1 the build happens within the Azure DevOp Pipeline and therefore the
        # are corrisponding DotNetCoreCLI@2 tasks one to build it, the other to publish
        # it as a website AND to publish the published website to the PSD/WebApp1.
        # Conversely, WebApp2 requires only a single Docker@2 task.

        # https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/dotnet-core-cli-v2?view=azure-pipelines
        #- task: DotNetCoreCLI@2
        #  displayName: Build WebApp1 with the .Net Core SDK   
        #  inputs:
        #    command: 'custom'
        #    custom: 'build'
        #    arguments: '--configuration $(buildConfiguration)'
        #    projects: '**/WebApp1/*.csproj'
                 
          
        #- task: DotNetCoreCLI@2
        #  displayName: Publish WebApp1 with the .Net Core SDK   
        #  inputs:            
        #    command: 'publish'
        #    arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)'
        #    projects: '**/WebApp1/*.csproj'
        #    # in this case we want to publish a specific web project in the WebApp1 subfolder
        #    publishWebProjects: false 
        #    # in this case we want the publish to leave the folder with the published content unzipped
        #    zipAfterPublish: false  
        #    # Add project's folder name to publish path boolean. Optional. Use when command = publish. Default value: true.
        #    modifyOutputPath: true 
        
        # -------------------------------------------------------------------------------------------------------
        # Diagnostics on the Azure DevOps Pipeline Filesystem

        # /home/vsts/work/1/s
        - powershell: |
           Write-Host "Content of Build.Repository.LocalPath = $(Build.Repository.LocalPath)"
           Get-ChildItem -Path $(Build.Repository.LocalPath)\* -Recurse -Force | Out-String -Width 160
          errorActionPreference: continue
          displayName: 'pwsh Get-ChildItem of Build.Repository.LocalPath = $(Build.Repository.LocalPath)'
          continueOnError: true

        - powershell: |
           Write-Host "Content of Build.Repository.LocalPath/WebApp1 = $(Build.Repository.LocalPath)/WebApp1"
           Get-ChildItem -Path $(Build.Repository.LocalPath)/WebApp1\* -Recurse -Force | Out-String -Width 160
          errorActionPreference: continue
          displayName: 'pwsh Get-ChildItem of Build.Repository.LocalPath/WebApp1 = $(Build.Repository.LocalPath)/WebApp1'
          continueOnError: true

        - powershell: |
           Write-Host "Content of Build.Repository.LocalPath/WebApp2 = $(Build.Repository.LocalPath)/WebApp2"
           Get-ChildItem -Path $(Build.Repository.LocalPath)/WebApp2\* -Recurse -Force | Out-String -Width 160
          errorActionPreference: continue
          displayName: 'pwsh Get-ChildItem of Build.Repository.LocalPath/WebApp2 = $(Build.Repository.LocalPath)/WebApp2'
          continueOnError: true
          
        - powershell: |
           Write-Host "Content of Build.ArtifactStagingDirectory = $(Build.ArtifactStagingDirectory)"
           Get-ChildItem -Path $(Build.ArtifactStagingDirectory)\* -Recurse -Force | Out-String -Width 160
          errorActionPreference: continue
          displayName: 'pwsh Get-ChildItem of Build.ArtifactStagingDirectory = $(Build.ArtifactStagingDirectory)'
          continueOnError: true

        # -------------------------------------------------------------------------------------------------------  
                
        # https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/docker-v2?view=azure-pipelines&tabs=yaml
        # Docker@2 task from the pipeline editor
        # https://www.udemy.com/course/azure100/learn/lecture/33386646#overview
        # Example-1: Build a Docker Image from binaries.
        # This task takes the binaries published to the Pipeline's Staging subfolder WebApp1
        # and uses its DockerfileAzDevOps to build an image with the app from its binaries.
        # The DockerfileAzDevOps is extremely simplified in this case because the image is  
        # not going to be build from its source code by Docker in a multi-stage Dockerfile.
        #- task: Docker@2
        #  displayName: Build the Docker image for WebApp1 from the published binaries and push the tag to ACR  
        #  inputs:            
        #    command: 'buildAndPush'
        #    # containerRegistry must be set to the name of the Service Connection to the Docker 
        #    # available to this pipeline
        #    containerRegistry: 'containerRegistryServiceConnection'
        #    repository: '$(imageRepository)'
        #    buildContext: '$(Build.ArtifactStagingDirectory)/WebApp1' 
        #    # notice here that although the bildContext is set to WebApp1 you still need
        #    # to prepend the name of the Dockerfile to be used with the folder name WebApp1
        #    Dockerfile: 'WebApp1/DockerfileAzDevOps'
        #    # for image tags the _ is the only separator allowed
        #    tags: | 
        #      wa1-$(buildTag)          

        # -------------------------------------------------------------------------------------------------------
        
        # https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/docker-v2?view=azure-pipelines&tabs=yaml
        # Docker@2 task from the pipeline editor
        # Example-2: Build a Docker Image from souce code with a multistage Dockerbuild.
        # https://www.udemy.com/course/azure100/learn/lecture/33386896#overview
        # In this step we are going to use the same Dockerfile that Visual Studio uses
        # to build the image locally and spin up the container for debugging.
        # However, this is done in the Agent of the Azure DevOps Pipeline that executes
        # this step of the pipeline. Notice that the step itself is executed on the Agent
        # therefore the underlying OS must have Docker installed on it.The source code
        # is first copied to an intermediate container materialized from an an image that 
        # can build .Net Core projects then the next step of the Dockerfile multistage 
        # copies the binaries produced buy yhis build into a new image that supports the 
        # .net Core runtime.This is alos the image that is later tagged and eventually 
        # pushed to our ACR to be consumed.
        #- task: Docker@2
        #  displayName: Build the Docker image for WebApp2 from the source code and push the tag to ACR  
        #  inputs:            
        #    command: 'buildAndPush'
        #    # containerRegistry must be set to the name of the Service Connection to the Docker 
        #    # available to this pipeline
        #    containerRegistry: 'containerRegistryServiceConnection'
        #    repository: '$(imageRepository)'            
        #    Dockerfile: 'WebApp2/Dockerfile'
        #    tags: | 
        #      wa2-$(buildTag)

        # -------------------------------------------------------------------------------------------------------

        #- script: echo Hello, world!
        #  displayName: 'Run a one-line script'

        #- script: |
        #    echo Add other tasks to build, test, and deploy your project.
        #    echo See https://aka.ms/yaml
        #  displayName: 'Run a multi-line script'

  - stage: CD
    displayName: CD Stage
    jobs:
        # Deplyment Jobs
        # https://learn.microsoft.com/en-us/azure/devops/pipelines/process/deployment-jobs?view=azure-devops
        # Azure DevOps Environments EXPLAINED
        # https://www.youtube.com/watch?v=gN4j65w7wIM&t=203s
      - deployment: DeployWebApps
        displayName: Deploy_containers_from_the_ACR_to_the_corresponding_container_services_on_Azure           
        pool:
          vmImage: windows-2022
          #vmImage: ubuntu-latest
        environment: Dev
        strategy: # Default deployment strategy, more coming...     
          runOnce:
            deploy:
              steps:      
              # Release/Deploy to Azure Container Instances 
              # https://www.udemy.com/course/azure100/learn/lecture/33386754#overview
              # https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/azure-cli-v2?view=azure-pipelines
              - task: AzureCLI@2
                displayName: deploy WebApp1 to ACR  
                inputs:
                  azureSubscription: 'Visual Studio Professional with MSDN (df17c9fe-de76-4143-bbae-77b75fa0705b)' 
                  #scriptType: # 'ps' | 'pscore' | 'batch' | 'bash'. Required. Script Type. 
                  scriptType: 'batch'
                  #scriptLocation: 'scriptPath' # 'inlineScript' | 'scriptPath'. Required. Script Location. Default: scriptPath.
                  #------------------------------------------------------------
                  scriptLocation: 'inlineScript'            
                  inlineScript: |
                    az --version
                    az account show            
                  #------------------------------------------------------------
                  #scriptLocation: 'scriptPath'
                  #arguments: '$(AZURE_STORAGE_ACCOUNT) $(AZURE_STORAGE_KEY)'    
                  #scriptPath: './scripts/publish.ps1'
                  #------------------------------------------------------------

# az container create -g devops-grp --name appinstance20030 --cpu 1 --memory 1  --ports 80 --ip-address Public --image registry57767.azurecr.io/sqlappdocker:latest --registry-username registry57767 --registry-password XeVWwKmmKD2IAS34A8B8i7E+MWJlneju
# az container create 
# -g devops-grp --name appinstance20030 
# --cpu 1 --memory 1  --ports 80 --ip-address Public 
# --image registry57767.azurecr.io/sqlappdocker:latest 
# --registry-username registry57767 --registry-password XeVWwKmmKD2IAS34A8B8i7E+MWJlneju

        #steps:
        #- script: echo Hello, world!
        #  displayName: 'Run a one-line script'

        #- script: |
        #    echo Add other tasks to build, test, and deploy your project.
        #    echo See https://aka.ms/yaml
        #  displayName: 'Run a multi-line script'
